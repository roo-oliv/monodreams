Implement the following plan:

# Fix: Silhouette Y-sort not using collider bottom coordinate

## Context

When collider children (e.g., `pete-collider`, `Boldo-collider`) are applied to parent entities, `ApplyColliderChild` sets `YSortOffset` on the **parent's** `SpriteInfo` so it Y-sorts by the collider's bottom edge. However, child entities like silhouettes (e.g., `elephant-kid-shilhouette`) never receive this `YSortOffset`. They sort by `WorldPosition.Y + 0` (entity center) instead of by the collider bottom.

This means: when the player walks behind an NPC, the NPC sorts correctly (by collider bottom), but the silhouette sorts by a higher Y value (entity center), causing it to appear **in front** of the player when it should be behind.

## Execution order in the parser

1. **Pre-scan**: Identify collider children
2. **Pass 1**: Create entities + run collection handlers (sets `YSortDepthBias` on silhouettes)
3. **Post-Pass 1**: `ApplyColliderChild` → sets `YSortOffset` on **parent only**
4. **Pass 2**: Set up parent-child hierarchy

`YSortOffset` isn't available during Pass 1 (when the NPC collection handler runs), so the silhouette can't copy it at that point.

## Fix

Add a propagation step after Pass 2 in `BlenderLevelParserSystem.cs` (line ~174) that copies `YSortOffset` from parent to child entities that have `SpriteInfo`:

```csharp
// Post-Pass 2: Propagate YSortOffset from parents to sprite children
foreach (var obj in levelData.Objects)
{
    if (string.IsNullOrEmpty(obj.Parent)) continue;
    if (colliderChildNames.Contains(obj.Name)) continue;

    if (!_nameToEntity.TryGetValue(obj.Name, out var childEntity)) continue;
    if (!_nameToEntity.TryGetValue(obj.Parent, out var parentEntity)) continue;

    if (childEntity.Has<SpriteInfo>() && parentEntity.Has<SpriteInfo>())
    {
        ref readonly var parentSprite = ref parentEntity.Get<SpriteInfo>();
        if (parentSprite.YSortOffset != 0f)
        {
            ref var childSprite = ref childEntity.Get<SpriteInfo>();
            childSprite.YSortOffset = parentSprite.YSortOffset;
            Logger.Debug($"Propagated YSortOffset={parentSprite.YSortOffset} from '{obj.Parent}' to '{obj.Name}'.");
        }
    }
}
```

## File to modify

- `MonoDreams/System/Level/BlenderLevelParserSystem.cs` — add propagation step after Pass 2 (~line 174)

## Verification

1. `dotnet build MonoDreams.Examples/MonoDreams.Examples.csproj`
2. Run the game, walk the player behind an NPC with a silhouette — the silhouette should render behind the player when the player is in front (lower on screen), and in front of the player when the player is behind (higher on screen)


If you need specific details from before exiting plan mode (like exact code snippets, error messages, or content you generated), read the full transcript at: /Users/rodrigooliveira/.REDACTED.jsonl

---

(/Users/rodrigooliveira/Desktop/Captura de Tela 2026-02-23 às 14.45.42.png) It's almost perfect, there is just one corner case when the player (the penguin) is right in the middle height probably where the YSorting change happen: the player is sorted behind the elephant-kid but above the elephant-kid-shilhouette. Using the in-game inspector I tried to watch the Transforms but couldn't find the transforms for the colliders or a way to view them, they appear as an opaque object name instead of readable properties (can you fix that as well?)

---

[Request interrupted by user for tool use]